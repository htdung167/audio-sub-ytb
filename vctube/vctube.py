import json
import os
import shutil
from functools import partial
from glob import glob
from typing import Any

import pandas as pd
import tqdm
import yt_dlp as youtube_dl
from pydub import AudioSegment
from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api._errors import NoTranscriptFound

from .utils import makedirs, parallel_run

import concurrent.futures


class VCtube:
    def __init__(
            self, 
            output_dir: str, 
            youtube_url: str, 
            lang: str,
            merge_subtitle: bool,
            max_time: float,
            allowable_distance: float,
            skip_autogenerated: bool,
            max_workers: int
            ) -> None:
        self.output_dir = output_dir
        self.lang = lang
        self.merge_subtitle = merge_subtitle
        self.max_time = max_time
        self.allowable_distance = allowable_distance
        self.skip_autogenerated = skip_autogenerated
        self.max_workers = max_workers

        if isinstance(youtube_url, str):
            if youtube_url.endswith(".txt"):
                content = open(youtube_url, 'r', encoding='utf-8').read().strip().split("\n")
                content = [k.strip() for k in content]
                self.youtube_url = content

            else:
                self.youtube_url = [youtube_url,]
        
        elif isinstance(youtube_dl, list):
            self.youtube_url = youtube_url
        
        else:
            raise Exception("youtube_url must be string or list!")


        # Delete directory if existing
        if os.path.exists(self.output_dir):
            shutil.rmtree(self.output_dir, ignore_errors=True)
        os.makedirs(self.output_dir, exist_ok=True)

    def run(self):
        self.download_audio(self.max_workers)

        self.download_captions(
            skip_autogenerated=self.skip_autogenerated,
            merge_subtitle=self.merge_subtitle,
            max_time=self.max_time,
            allowable_distance=self.allowable_distance
            )

        self.audio_split()

    def download_audio(self, max_workers=2) -> None:
        download_path = os.path.join(self.output_dir, "wavs/" + '%(id)s.%(ext)s')

        # youtube_dl options
        ydl_opts = {
            'format': 'bestaudio/best',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'wav',
                'preferredquality': '192'
            }],
            'postprocessors_args': [
                '-ar', '21000'
            ],
            'prefer_ffmpeg': True,
            'keepvideo': False,
            'outtmpl': download_path,  
            'ignoreerrors': True
        }

        def dl_video(url):

            try:
                with youtube_dl.YoutubeDL(ydl_opts) as ydl:
                    ydl.download([url])
                    return url, True
            except Exception as e:
                print('error', e)
                return url, False

        futures = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            for url in self.youtube_url:
                futures.append(executor.submit(dl_video, url))
        
        for future in concurrent.futures.as_completed(futures):
            res = future.result()
            url, status = res 

            if status:
                print(f"Download {url} successfully!")
            else:
                print(f"Download {url} failed!")

    def download_captions(self, skip_autogenerated=False, merge_subtitle=True, max_time=30, allowable_distance=0.5) -> None:
        lang = self.lang
        video_id = []
        text = []
        start = []
        duration = []
        names = []
        full_names = []
        wav_dir = os.path.join(self.output_dir, "wavs")
        file_list = os.listdir(wav_dir)
        file_list_wav = [file for file in file_list if file.endswith(".wav")]

        for f in tqdm.tqdm(file_list_wav):
            try:
                video = f.split(".wav")[0]

                if skip_autogenerated:
                    try:
                        transcript_list = YouTubeTranscriptApi.list_transcripts(video)
                        subtitle = transcript_list.find_manually_created_transcript([lang])
                        subtitle = subtitle.fetch()
                    except NoTranscriptFound:
                        msg = "Skipping video {} because it has no manually generated subtitles"
                        print(msg.format(video))
                        
                        continue
                else:
                    subtitle = YouTubeTranscriptApi.get_transcript(video, languages=[lang])

                for s in range(len(subtitle) - 1):
                    video_id.append(video)
                    full_name = os.path.join(wav_dir, video + '.' + str(s).zfill(4) + '.wav')
                    full_names.append(full_name)
                    name = video + '.' + str(s).zfill(4) + '.wav'
                    names.append(name)

                    text.append(subtitle[s]['text'])
                    start.append(subtitle[s]['start'])
                    if subtitle[s]['duration'] >= (subtitle[s + 1]['start'] - subtitle[s]['start']):
                        duration.append(subtitle[s + 1]['start'] - subtitle[s]['start'])
                    else:
                        duration.append(subtitle[s]['duration'])

            except Exception as e:
                print("error:", e)
        
        unique_video_id = list(set(video_id))
        text_dir = os.path.join(self.output_dir, "text")
        makedirs(text_dir)

        # Merge subtitles
        if merge_subtitle:
            dic = dict()
            for video in unique_video_id:
                dic[video] = []
            
            for idx in range(len(text)):
                dic[video_id[idx]].append(
                    {
                        'start': start[idx],
                        'duration': duration[idx],
                        'text': text[idx]
                    }
                )

            final_text = []
            final_start = []
            final_duration = []
            final_video_id = []

            for key, value in dic.items():

                new_text = []
                new_start = []
                new_duration = []
                new_video_id = []

                text_temp = ""
                start_temp = 0
                duration_temp = 0

                for idx in range(len(value)):

                    

                    ttt = value[idx]["text"]
                    if ttt.startswith("[") and ttt.endswith("]") and ttt.count("[") == 1 and ttt.count("]") == 1:
                        pass
                    else:
                        if duration_temp == 0:
                            text_temp = value[idx]["text"]
                            start_temp = value[idx]["start"]
                            duration_temp = value[idx]["duration"]
                            continue

                        text_temp_temp = f'{text_temp} {value[idx]["text"]}'.strip()
                        start_temp_temp = start_temp
                        duration_temp_temp = value[idx]["start"] - start_temp + value[idx]["duration"]

                        if duration_temp_temp > max_time or \
                            value[idx]["start"] - (start_temp + duration_temp) > allowable_distance:

                            new_text.append(text_temp)
                            new_start.append(start_temp)
                            new_duration.append(duration_temp)
                            new_video_id.append(key)

                            text_temp = value[idx]["text"]
                            start_temp = value[idx]["start"]
                            duration_temp = value[idx]["duration"]

                        else:
                            text_temp = text_temp_temp
                            start_temp = start_temp_temp
                            duration_temp = duration_temp_temp
                    
                    if idx >= len(value) - 1:
                        new_text.append(text_temp)
                        new_start.append(start_temp)
                        new_duration.append(duration_temp)
                        new_video_id.append(key)


                
                final_text.extend(new_text)
                final_start.extend(new_start)
                final_duration.extend(new_duration)
                final_video_id.extend(new_video_id)
            
            text = final_text
            start = final_start
            duration = final_duration
            video_id = final_video_id

            names = []
            full_names = []

            for idx in range(len(video_id)):
                full_name = os.path.join(wav_dir, video_id[idx] + '.' + str(idx).zfill(4) + '.wav')
                full_names.append(full_name)
                name = video_id[idx] + '.' + str(idx).zfill(4) + '.wav'
                names.append(name)

        for uid in unique_video_id:
            text_result_json_path = os.path.join(text_dir, f"{uid}.json")
            text_result = {
                "id": uid,
                "wav_path": os.path.join(wav_dir, uid + '.wav'),
                "subtitles": []
            }

            ttt_id = 0
            for idx, (vid, txt, start_t, duration_t, name, full_name) in enumerate(zip(video_id, text, start, duration, names, full_names)):
                if vid == uid:
                    
                    text_result["subtitles"].append(
                        {
                            "order": ttt_id,
                            "wav_path": full_name,
                            "name": name,
                            "text": txt,
                            "start": start_t,
                            "duration": duration_t
                        }
                    )
                    ttt_id += 1


            # Save json
            with open(text_result_json_path, 'w', encoding='utf-8') as f:
                json.dump(text_result, f, indent=4, ensure_ascii=False)
            
        print(os.path.basename(self.output_dir) + ' channel was finished')
        

    def audio_split(self, parallel=False) -> None:
        base_dir = self.output_dir + '/wavs/*.wav'
        audio_paths = glob(base_dir)
        audio_paths.sort()
        fn = partial(split_with_caption)
        parallel_run(fn, audio_paths, desc="Split with caption", parallel=parallel)


def split_with_caption(audio_path, skip_idx=0, out_ext="wav") -> list:
    audio_paths = []
    text_result_json_path = audio_path.replace("/wavs/", '/text/').rsplit(".", 1)[0] + ".json"
    filename = os.path.basename(audio_path).split('.', 1)[0]

    if not os.path.exists(text_result_json_path):
        print(f"{text_result_json_path} must exist!")
        if os.path.exists(audio_path):
            os.remove(audio_path)
        return audio_paths

    audio = read_audio(audio_path)

    with open(text_result_json_path, 'r', encoding='utf-8') as f:
        subtitles_info = json.load(f)["subtitles"]

    edges = []

    for subtitle_info in subtitles_info:
        edges.append(
            [
                int(subtitle_info["start"] * 1000),
                int((subtitle_info["start"] + subtitle_info['duration']) * 1000)

            ]
        )

    for idx, (start_idx, end_idx) in enumerate(edges[skip_idx:]):
        start_idx = max(0, start_idx)

        target_audio_path = "{}/{}.{:04d}.{}".format(
            os.path.dirname(audio_path), filename, idx, out_ext)

        segment = audio[start_idx:end_idx]

        segment.export(target_audio_path, "wav")  # for soundsegment

        audio_paths.append(target_audio_path)

    return audio_paths


def read_audio(audio_path):
    return AudioSegment.from_file(audio_path)
